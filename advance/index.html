<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Cellink 进阶 | Cellink 用户手册</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/hexo-fluid-docs/imgs/icon.png">
    <meta name="description" content="一款可视化代码流程管理框架">
    <meta property="article:modified_time" content="null">
    <meta property="og:site_name" content="Cellink">
    <meta property="og:title" content="Cellink 进阶">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://fluid-dev.github.io//advance/">
    <meta name="twitter:title" content="Cellink 进阶">
    <meta name="twitter:url" content="https://fluid-dev.github.io//advance/">
    <meta name="twitter:card" content="/favicon.png">
    <meta name="keywords" content="hexo,theme,fluid,hexo主题,fluid文档,用户文档,博客,文档,博客,文章,docs,doc,documentation,document,guide,blog,post,article">
    
    <link rel="preload" href="/hexo-fluid-docs/assets/css/0.styles.3f700e40.css" as="style"><link rel="preload" href="/hexo-fluid-docs/assets/js/app.b0ff0082.js" as="script"><link rel="preload" href="/hexo-fluid-docs/assets/js/2.79f3453a.js" as="script"><link rel="preload" href="/hexo-fluid-docs/assets/js/8.d9809693.js" as="script"><link rel="prefetch" href="/hexo-fluid-docs/assets/js/10.68d196fd.js"><link rel="prefetch" href="/hexo-fluid-docs/assets/js/11.ac874c15.js"><link rel="prefetch" href="/hexo-fluid-docs/assets/js/3.43512d44.js"><link rel="prefetch" href="/hexo-fluid-docs/assets/js/4.96039860.js"><link rel="prefetch" href="/hexo-fluid-docs/assets/js/5.74f82d90.js"><link rel="prefetch" href="/hexo-fluid-docs/assets/js/6.6ead7621.js"><link rel="prefetch" href="/hexo-fluid-docs/assets/js/7.cf9d6ec2.js"><link rel="prefetch" href="/hexo-fluid-docs/assets/js/9.293d2c90.js">
    <link rel="stylesheet" href="/hexo-fluid-docs/assets/css/0.styles.3f700e40.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/hexo-fluid-docs/" class="home-link router-link-active"><!----> <span class="site-name">Cellink 用户手册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/hexo-fluid-docs/start/" class="nav-link">
  开始使用
</a></div><div class="nav-item"><a href="/hexo-fluid-docs/guide/" class="nav-link">
  配置指南
</a></div><div class="nav-item"><a href="/hexo-fluid-docs/advance/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  进阶用法
</a></div><div class="nav-item"><a href="/hexo-fluid-docs/practice/" class="nav-link">
  Cellink 实践
</a></div><div class="nav-item"><a href="https://github.com/viibridges/cellink" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/hexo-fluid-docs/start/" class="nav-link">
  开始使用
</a></div><div class="nav-item"><a href="/hexo-fluid-docs/guide/" class="nav-link">
  配置指南
</a></div><div class="nav-item"><a href="/hexo-fluid-docs/advance/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  进阶用法
</a></div><div class="nav-item"><a href="/hexo-fluid-docs/practice/" class="nav-link">
  Cellink 实践
</a></div><div class="nav-item"><a href="https://github.com/viibridges/cellink" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Cellink 进阶</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/hexo-fluid-docs/advance/#cellink-进阶" class="sidebar-link">Cellink 进阶</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/hexo-fluid-docs/advance/#量子节点" class="sidebar-link">量子节点</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="cellink-进阶"><a href="#cellink-进阶" class="header-anchor">#</a> Cellink 进阶</h2> <p>面向熟练使用者，Cellink 提供了一些高级特性。</p> <h3 id="量子节点"><a href="#量子节点" class="header-anchor">#</a> 量子节点</h3> <p>借用了量子力学的术语。Cellink 允许开发者构建所谓的“量子节点”。下图中的 Square 节点就是一个量子节点：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>NodeSI<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">12</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>NodeSI<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token number">2</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>


<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span><span class="token punctuation">[</span>A<span class="token punctuation">,</span> B<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">Square</span><span class="token punctuation">(</span>NodeSI<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        val <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>val
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val <span class="token operator">*</span> val
        <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre></div><p>表面上看，Square 节点与普通节点并无不同，但 Square 节点的“两个父节点”被放在方括号里。</p> <p>这样的挂载方式在 Square 节点看来只挂载了一个父节点，但自己变成了两个分身。我们称 Square 节点处于<strong>量子态</strong>，它的量子态数量为 2 。</p> <p><em>量子节点本质上是共享一个节点名称和类定义的多个节点的集合。</em></p> <p><em>某种意义上说，普通节点也是量子节点，它们的量子态数量为 1 。</em></p> <h4 id="hook-parent-的拓展"><a href="#hook-parent-的拓展" class="header-anchor">#</a> @hook_parent 的拓展</h4> <p>在更详细说明量子态之前，请允许我先介绍 @hook_parent 装饰器的拓展特性。</p> <p>@hook_parent 装饰器完整的输入格式是：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>Node1<span class="token punctuation">,</span> id1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>Node2<span class="token punctuation">,</span> id2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre></div><p>@hook_parent 装饰器的每个入参（Argument）代表一个父节点。它可以是一个节点类，或者 tuple 类型，或者节点类和 tuple 类型的混合列表（list）。这三种形式对挂载它的量子节点来说都是一个父节点。</p> <p>其中 tuple 类型表示“坍缩”操作，用于析取量子节点的量子态。它的第一个元素为节点类，第二个元素为非负整数，表示所析取的第几个量子态：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Node<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 析取 Node 的第一个量子态作为父节点</span>
<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Node<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 析取 Node 的第二个量子态作为父节点</span>
</code></pre></div><p>普通的挂载方式只是参数格式上的简化：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 假设 Node1 和 Node2 的量子态数量都为 1，即普通节点</span>
<span class="token comment"># 以下两个表达式完全等价</span>
<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span>Node1<span class="token punctuation">,</span> Node2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>Node1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>Node2<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>@hook_parent 装饰器也支持混合格式：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span>Node1<span class="token punctuation">,</span> <span class="token punctuation">(</span>Node2<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Node1<span class="token punctuation">,</span> <span class="token punctuation">(</span>Node2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Node3<span class="token punctuation">]</span>， Node4<span class="token punctuation">)</span>
</code></pre></div><p>@hook_parent 装饰器接收参数时的原则只有一个：所有父节点的量子态数量须保持一致。</p> <p>这样做是为了保持父节点量子态之间的对应关系。因为子节点的量子态须和父节点的量子态一一对应。</p> <p>假设一个多输入节点有两个父节点 Node1 和 Node2，那么一般来说 Node1 的量子态必须和 Node2 的相等。</p> <p>然而也有例外。 @hook_parent 支持类似 numpy 里的 dimension broadcasting 。量子态为 1 的父节点会自动扩展自己的量子态，与其它父节点的量子态数量保持一致：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 假设 Node1/2/3 都是量子态为 1 的普通节点</span>
<span class="token comment"># 那以下输入格式也是合法的，因为 Node1 会自动扩展成 [Node1, Node1] 与 [Node2, Node3] 保持一致</span>
<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span>Node1<span class="token punctuation">,</span> <span class="token punctuation">[</span>Node2<span class="token punctuation">,</span> Node3<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 因为量子态的一一对应关系，上一条语句的效果类似于两个多输入类型的子节点挂载不同的父节点组合</span>
<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span>Node1<span class="token punctuation">,</span> Node2<span class="token punctuation">)</span> <span class="token comment"># 第一个量子态的等效</span>
<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span>Node1<span class="token punctuation">,</span> Node3<span class="token punctuation">)</span> <span class="token comment"># 第二个量子态的等效</span>
</code></pre></div><h4 id="量子节点的特性"><a href="#量子节点的特性" class="header-anchor">#</a> 量子节点的特性</h4> <p>子节点的量子态数量和父节点的量子态数量相等。</p> <p>在有量子节点的图中，traverse 方法只遍历所有节点的第一个量子态。</p> <p>运行 seek 方法时，Cellink 会根据目标节点的量子态，选择其它节点相对应的量子态运行。</p> <p>seek 量子节点的结果等效于 seek 该节点的第一个量子态。想要 seek 其它量子态，需要创建新节点并在 @hook_parent 装饰器里“坍缩”到想要的量子态：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment"># 接之前的代码</span>
<span class="token decorator annotation punctuation">@hook_parent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Square<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">BSquare</span><span class="token punctuation">(</span>NodeSI<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> self<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>val
        <span class="token keyword">return</span> <span class="token boolean">True</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    node <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token string">'BSquare'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
</code></pre></div><p>以上代码展示了如何从量子节点“坍缩”到普通节点。@hook_parent((Square, 1)) 表示挂载量子节点 Square 的第二个量子态，即和节点 B 对应的量子态。</p> <p>输出结果是 4 。</p> <p>下图是上面两段代码的流程视图：</p> <p><img src="assets/imgs/quantum-graph.png" alt=""></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/zywvvd/cellink-docs/edit/source/docs/advance/README.md" target="_blank" rel="noopener noreferrer">帮助我们完善文档</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">文档更新于:</span> <span class="time">2022年9月20日 23:17</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/hexo-fluid-docs/assets/js/app.b0ff0082.js" defer></script><script src="/hexo-fluid-docs/assets/js/2.79f3453a.js" defer></script><script src="/hexo-fluid-docs/assets/js/8.d9809693.js" defer></script>
  </body>
</html>
